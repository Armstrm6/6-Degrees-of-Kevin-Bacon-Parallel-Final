# -*- coding: utf-8 -*-
"""Parallel Computing Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xi6E-Ntft5McDTE4j9EafmQ7PAUgwmvR
"""

import pandas as pd
import random

actors = pd.read_html('actors.html')
casts  = pd.read_html('casts.html')

actorsTable = pd.DataFrame(columns = ['stage', 'dow', 'birth', 'giv', 'gen', 'dob', 'dod', 'type', 'orig',
                         'pict', 'notes'])
for table in actors:
  data = pd.DataFrame(data = table[['stage', 'dow', 'birth', 'giv', 'gen', 'dob', 'dod', 'type', 'orig',
                         'pict', 'notes']])
  actorsTable = actorsTable.append(data, ignore_index=True)

castsTable = pd.DataFrame(columns = ['movie', 'actor', 'type', 'role'])
for table in casts:
  first_column = table.iloc[:, 1]
  print(first_column.name)
  print(table.info())
  if((first_column.name != 'title') and (first_column.name != 1) and (first_column.name != 'actor')):
    try:
      data = pd.DataFrame(data = table[[first_column.name, 'actor', 'type', 'role']])
      data = data.rename(columns = {first_column.name: 'movie'})
    except:
      try:
        data = pd.DataFrame(data = table[[first_column.name, 'actot', 'type', 'role']])
        data = data.rename(columns = {first_column.name: 'movie', 'actot':'actor'})
      except:
        print('error')
        break;

    castsTable = castsTable.append(data, ignore_index=True)
    castsTable.reset_index()

castsTable

actorsTable.to_csv('actors.csv')
castsTable.to_csv('casts.csv')

casts = pd.read_csv('casts.csv')
person1 = 'Jack Nance'
person2 = 'Demi Moore'
finalActor = ''
data = pd.DataFrame()

def actorList (actorInput):
  actors = pd.DataFrame()
  movies = pd.DataFrame()
  movies = casts[(casts.actor == actorInput)]
  for row in movies.movie:
    actors = actors.append(casts[(casts.movie ==row)])
  return actors

returnedActors = actorList(person1)
count = 1
while finalActor != person2:
  print(count)
  data = pd.DataFrame()
  for actor in returnedActors.actor:
    if(actor == person2):
      finalActor = actor;
      break;
    data = data.append(actorList(actor))
  count = count +1
  returnedActors = data
print(count)

from multiprocessing import Process
from multiprocessing import Pool
from concurrent.futures import ProcessPoolExecutor
from concurrent.futures import ThreadPoolExecutor
import numpy as np

casts = pd.read_csv('casts.csv')
person1 = 'Jack Nance'
person2 = 'Demi Moore'
finalActor = ''


def actorList (actorInput):
  aa = pd.DataFrame()
  movies = pd.DataFrame()
  if(type(actorInput) == str):
    movies = casts[(casts.actor == actorInput)]
    for row in movies.movie:
      aa = aa.append(casts[(casts.movie ==row)])
  else:
    for actors in actorInput.actor:
      movies = casts[(casts.actor == actors)]
      for row in movies.movie:
        aa = aa.append(casts[(casts.movie ==row)])
  return aa

returnedActors = actorList(person1)
count = 1

executor = ThreadPoolExecutor(max_workers = 10)
print(returnedActors.size)

while finalActor != person2:
  
  block = np.array_split(returnedActors, 10)

  returnedActors = pd.DataFrame()
  feedback = pd.DataFrame()

  for data in block:
    returnData = executor.submit(actorList, data)
    feedback = returnData.result()
    returnedActors = returnedActors.append(feedback)
  returnedActors = returnedActors.drop_duplicates(subset=["movie", "actor"], keep='first')  
  for actor in returnedActors.actor:
    if(actor == person2):
      finalActor = actor;
      break;
  print(returnedActors.size)
  count = count + 1
print(count)   
print(finalActor)





